{"version":3,"file":"scroll-scrub-video-component.js","sourceRoot":"","sources":["../src/scroll-scrub-video-component.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n\nimport { styles } from './styles';\n\ninterface VideoContainer extends HTMLElement {\n  // A reference back to this VideoContainer's parent ScrollScrubVideoComponent \n  ScrollScrubVideoComponent: ScrollScrubVideoComponent;\n}\n\ninterface ComponentData {\n  lower: number;\n  upper: number;\n  video: HTMLVideoElement | null;\n}\n\n// Static class members\nconst componentDataMap = new WeakMap<ScrollScrubVideoComponent, ComponentData>();\nlet observer: IntersectionObserver;\n\n// The active component, if there is one\nlet activeScrollScrubComponent: ScrollScrubVideoComponent | null;\nconst allScrollScrubComponents: Set<ScrollScrubVideoComponent> = new Set();\nconst observedElements: Set<ScrollScrubVideoComponent> = new Set();\nconst OVERSCRUB_AVOIDANCE_FACTOR = 0.99;\n\n\nclass ScrollScrubVideoComponent extends HTMLElement {\n  minWidth: number;\n  isHidden: boolean;\n  zoomDuration: number;\n  video: HTMLVideoElement | null;\n  src: string | null;\n\n  constructor() {\n    super();\n    ScrollScrubVideoComponent.maybeDoStaticInitialisation();\n\n    // Initialise instance members\n    this.minWidth = parseInt(this.getAttribute('min-width') ?? '0', 10);\n    this.isHidden = false;\n    this.zoomDuration = parseFloat(getComputedStyle(this).getPropertyValue('--zoom-duration') || '0.2s');\n\n    this.video = null;\n    this.src = null;\n  }\n\n  connectedCallback() {\n    this.attachShadow({ mode: \"open\" });\n\n    if (this.minWidth) {\n      if (window.innerWidth >= this.minWidth) {\n        this.loadAndObserve();\n      } else {\n        this.style.display = 'none';\n        this.isHidden = true;\n      }\n    } else {\n      this.loadAndObserve();\n    }\n    allScrollScrubComponents.add(this);\n  }\n\n  loadAndObserve() {\n    this.render();\n\n    // Get the video element\n    this.video = this.shadowRoot!.querySelector(\"video\");\n    if (!this.video) {\n      return;\n    }\n\n    // Preload the video\n    this.preloadVideo().then(() => {\n      // Setup this scrub-video\n      const videoContainer = this.shadowRoot!.querySelector('.scrub-video-container') as VideoContainer;\n\n      if (videoContainer) {\n        videoContainer.ScrollScrubVideoComponent = this;\n        observer.observe(videoContainer);\n        observedElements.add(this);\n\n        // Update the positions of all scrub-videos\n        ScrollScrubVideoComponent.updateallScrollScrubComponents();\n      } else {\n        console.warn(\"scrub-video-container not found in shadow DOM\");\n      }\n    });\n  }\n\n  disconnectedCallback() {\n    // If you were going to remove elements, you should update the\n    // ScrollScrubVideoComponent.allScrollScrubComponents set\n    // We're not going to do that here, that's left as an exercise\n  }\n\n  static maybeDoStaticInitialisation() {\n    if (!observer) {\n      observer = new IntersectionObserver(ScrollScrubVideoComponent.intersectionObserverCallback, { threshold: 1 });\n      document.addEventListener(\"scroll\", ScrollScrubVideoComponent.handleScrollEvent);\n      window.addEventListener(\"resize\", ScrollScrubVideoComponent.updateallScrollScrubComponents);\n    }\n  }\n\n  static intersectionObserverCallback(entries: IntersectionObserverEntry[], _: IntersectionObserver) {\n    entries.forEach(entry => {\n      const isWithinViewport = entry.intersectionRatio === 1;\n\n      const videoContainer = entry.target as VideoContainer;\n      const videoComponent = videoContainer.ScrollScrubVideoComponent;\n\n      if (!videoComponent) {\n        console.warn(\"No ScrollScrubVideoComponent found for videoContainer\", videoContainer);\n        return;\n      }\n\n      // Add class 'animating' to element if it is within the viewport\n      entry.target.classList.add('animating');\n      entry.target.classList.toggle('in-view', isWithinViewport);\n\n      // Remove the animation class after we're done zooming in or out\n      const delay = videoComponent.zoomDuration * 1000;\n      setTimeout(() => {\n        entry.target.classList.remove('animating');\n      }, delay);\n\n      if (isWithinViewport) {\n        activeScrollScrubComponent = videoComponent;\n        ScrollScrubVideoComponent.handleScrollEvent();\n      }\n    });\n  }\n\n  static updateallScrollScrubComponents() {\n    // Get new positions of scrub video components\n    allScrollScrubComponents.forEach((videoComponent) => {\n      const clientRect = videoComponent.getBoundingClientRect();\n      const { y, bottom } = clientRect;\n      const videoComponentTopPosition = y + window.scrollY;\n      const videoComponentBottomPosition = bottom - window.innerHeight + window.scrollY;\n\n      if (videoComponent.minWidth && window.innerWidth < videoComponent.minWidth) {\n        videoComponent.style.display = 'none';\n        videoComponent.isHidden = true;\n      } else if (videoComponent.isHidden && window.innerWidth >= videoComponent.minWidth) {\n        videoComponent.style.display = 'block';\n        videoComponent.isHidden = false;\n        if (!observedElements.has(videoComponent)) {\n          videoComponent.loadAndObserve();\n        }\n      }\n\n      componentDataMap.set(videoComponent, {\n        lower: videoComponentTopPosition,\n        upper: videoComponentBottomPosition,\n        video: videoComponent.shadowRoot!.querySelector('video')\n      });\n    });\n\n  };\n\n  static handleScrollEvent() {\n    if (activeScrollScrubComponent) {\n      const activeWrapperPosition = componentDataMap.get(activeScrollScrubComponent);\n\n      if (!activeWrapperPosition) {\n        return;\n      }\n\n      const { lower, upper, video } = activeWrapperPosition;\n\n      if (video) {\n        // Calculate the scroll progress within the active video wrapper\n        const progress = Math.max(Math.min((window.scrollY - lower) / (upper - lower), OVERSCRUB_AVOIDANCE_FACTOR), 0);\n        const seekTime = (progress * video.duration);\n\n        // console.log(`${wrapperTopPosition} > ${window.scrollY} (${progress}) [${seekTime}] duration: ${video.duration} > ${wrapperBottomPosition}`);\n        if (isFinite(seekTime) && !isNaN(video.duration)) {\n          video.currentTime = seekTime;\n        }\n      }\n    }\n  };\n\n  preloadVideo(): Promise<void> {\n    if (this.src) {\n      return fetch(this.src)\n        .then((response) => {\n          return response.blob()\n        })\n        .then((response) => {\n          let blobURL = URL.createObjectURL(response);\n          if (this.video) {\n            this.video.setAttribute(\"src\", blobURL);\n          }\n          this.classList.add('video-loaded');\n        });\n    }\n    return Promise.resolve();\n  }\n\n  render() {\n    this.src = this.getAttribute('src');\n\n    // Is there are Firefox=only src?\n    let firefoxSrc = this.getAttribute('firefox-src');\n    if (firefoxSrc) {\n      // Is this Firefox?\n      const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n      if (isFirefox) {\n        this.src = firefoxSrc;\n      }\n    }\n\n\n    this.shadowRoot!.innerHTML = `\n      ${styles}\n      <div class='scrub-video-container'>\n          <video src='${this.src}' muted  playsinline></video>\n      </div>`;\n  }\n\n}\n\ncustomElements.define(\"scroll-scrub-video\", ScrollScrubVideoComponent);\n\n// The following type makes it easier for other projects to use this component with TypeScript\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'scroll-scrub-video': ScrollScrubVideoComponent;\n  }\n}"]}